#+options: ^:nil

* Exercise

In this exercise, I am choosing to take a literate programming
approach.  I will be describing the design and writing blocks of
executable code using emacs org-mode babel, which provides the means to both
document and run essential pieces of the similator's code inside this
README.org document itself.

** Work in progress..

*** working

**** cuboid
***** mine layout
***** coordinate system
***** rendering
**** vessel
***** step execution
***** navigation and targeting
***** firing
**** step
***** parsing and lexing instructions
***** hit tracking
**** computer
***** calculations
****** smallest rectangle
****** relative ship centering on dimensions
**** grid
***** shrinking and growing face
***** rendering
**** simulator
***** execution of steps
***** state machine
**** test suite
***** unit test suite can be run with py.test
****** fluent expectation based tests
***** test coverage reports in html
****** builds website
**** facilities
***** command line execution scripts for both linux and windows
***** argument options parser with defaults
***** logger
****** output to local files, seperating info from errors
****** configured with local yaml file

*** todo

*** scoring
**** print output correctly
**** better validations
**** hit mine marking
**** NEED TO PUT IN MODULE DEPS INTO SETUP.PY
***** as it is, you'll have to figure out based on what breaks

*** known issues

**** there's a bug with shrininking and growing of space around the ship.
***** should be fixed by tweaking the simulation.recomput_cuboid() method

*** status

**** I'm close, but would like to continue work on the system to knock out the remaining features.
**** If you want to go ahead and begin evaluating the system, please go forward.

*** notables

**** lots of comprehension and lambda kung-fu for general purpose algorithms
**** liberal use of generator streams and map,reduce,filtration
**** pythonic functional idioms preferred over imperatives
**** test-driven design methodology followed
**** domain responsibilities are cleanly segmented and appropriately placed
**** developed with:
***** emacs
***** ipython
***** py.test, nose, sure (spec-based semantic assertions)
**** todo:
***** diagram system arch
***** diagram domain models
***** diagram program flow

** publication 

*** pdf
*** html

** similator program

** test suite

* Describe design

** requirements
**** pip install:
nose
mockito
sure
pytest
pytest-cov

** running
*** input
**** script file
contains the initial cuboid definition
**** field file
contains the student's mine sweeping solution steps
*** simulator program
serves as the executor of the script and field files
**** components
***** domain

represent's the entities within the simulation

****** input

the input is collected from a cuboid file and the student's script
file.  we put this information into data structures that are
appropriate for the job.  for this purpose we'll need a lexer and a parser.

first we'll consume the cuboid file

#+name: get_cuboid
#+header: :exports both
#+begin_src python 

  cuboid = open("./cuboid.dat", "r").read()
 
  return cuboid

#+end_src

#+RESULTS:
: ..Z..
: .....
: Z...Z
: .....
: ..Z..


next we'll get the steps that the student submitted to the simulator.

#+name: get_steps
#+header: :exports both
#+begin_src python 

  steps = open("./student_minesweeping_script.steps", "r").read().split("\n")

  return steps

#+end_src

#+RESULTS:
| north | delta south | west | gamma east | east | gamma west | south | delta |


****** cuboid

this is a data structure that represents our 3d coordinate system.
here we will turn the string into a cubic data structure that will allow us the track the ships position as it steps through moves.

#+name: build_cuboid
#+header: :exports both
#+begin_src python

  cuboid = """ .Z.
               ...
               Z.Z
               ...
               .Z. """

  # stub validation

  # compute height and width
  width = len(list(cuboid.split()[0].strip()))
  height = len(cuboid.split("\n"))

  # build a mapping char to value
  z_map = {c:i+1 for i,c in enumerate([chr(c) for c in 
                                       range(ord('a'), ord('z')+1)] + [chr(c) for c in range(ord('A'), ord('Z')+1)])}

  #compute depth
  import operator
  import re

  # get the order of the values
  ordered_z = sorted(z_map.items(), key=operator.itemgetter(1))

  # show the ordered_z
  for c,l in ordered_z:
     z = z_map[c] - 1
     print(c, z)

  # find the mines and order them from deepest to most shallow
  mine_chars = list(set(re.findall(r'[a-zA-Z]',cuboid)))

  deepest_mine = reduce(lambda highest,current: current if z_map[current] > z_map[highest] else highest, mine_chars)

  depth = z_map[deepest_mine]


  # generate a cubic data structure of correct dimensions
  cube_space = [[['.' for z in range(depth)] 
                 for y in range(height)] 
                for x in range(width)]

  # compute the mine coordinates in cubic space
  for y,line in enumerate(cuboid.strip().split("\n")):
     for x,char in enumerate(list(line.strip())):
        if char in mine_chars:
           z = z_map[char]-1
           cube_space[x][y][z] = char
           print(x,y,z)

  return cube_space     

#+end_src

#+RESULTS: build_cuboid
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) |
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) |
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) |



****** point (x,y,z)

points within the cuboid are represented as tuples

first we need to be able to find the center point of the x,y plane, in
order to place the ship at it's location

#+name: locate_ship
#+header: :var cuboid=build_cuboid :exports both
#+begin_src python

  def find_center(cuboid):
      width = len(cuboid)
      height = len(cuboid[0])
      center_point = ((width / 2) + (width % 2), (height / 2) + (height % 2))
      return center_point

  center_point = find_center(cuboid)

  return center_point

#+end_src

#+RESULTS: locate_ship
| 2 | 3 |

We also need to be able to recomput the size of the x,y plane based
upon the location of the ship and the mines

#+name: recompute_xy_plane
#+header: :var cuboid=build_cuboid ship_location=locate_ship :exports both
#+begin_src python

"todo"

#+end_src

#+RESULTS: recompute_xy_plane
: None

****** movement (z-1,[x,y,None])

movement within the cuboid corresponds to steps and is done with a
z-axis fall and a potential move on either the x or y axes.

****** distance

distance is tracked between points

this is used to find the center of the cuboid and to determine if
photon torpedo firing_patterns actually hit the mines

there is a hit tracking mechanism that computes a hit based on
distance, postion of points, and the firing pattern

****** firing_pattern (alpha,beta,gama,delta)

firing patterns are just tuples of 2d coordinates.  they are assumed
to go all the way to the bottom of the z-axis.

#+begin_src python

  firing_patterns = [alpha = ((-1, -1), (-1, 1), (1, -1), (1, 1))
                     beta = ((-1, 0), (0, -1), (0, 1), (1, 0))
                     gamma = ((-1, 0), (0, 0), (1, 0))
                     delta = ((0, -1), (0, 0), (0, 1))]

#+end_src


****** vessel (ship)

 #+BEGIN_EXAMPLE

         /\
        |==|
        |  |
        |  |
        |  |
       /____\
       |    |
       |Joel|
       |  IX|
       |    |
      /| |  |\
     / | |  | \
    /__|_|__|__\
       /_\/_\
       ######
      ########
       ######
        ####
        ####
         ##
         ##   
         ##
         ##

     #+END_EXAMPLE

the ship will have characteristics and behaviors.

characteristics:

position (x,y,z)
firing_patterns

behaviors:

fire
move
fall

#+begin_src python

  class Ship:

      firing_patterns = []

      def fire(self, pattern):
        print "pyoo pyoo pyoo"

#+end_src


****** step
****** score
****** output

***** services

behavior driver's for the simulation

step_executor
cuboid_computer
move_executor
score_computer
input_validator
input_parser
output_computer
firing_pattern_executor
hit_computer

*** output
contains the step executor's results 
**** output file


** composition

**** cuboid

contains a coordinate system of points

point's will be recomputed with each step

**** vessel

occupies a point (has a slot for a point)

**** move

contains 2 point slots

**** distance

is computed by evaluating the number of points (1km distance) between:

vessel and mines
vessel and edges of cuboid

* Describe approach

** Document and code along the way
** Write tests for the rules
*** use exemplar inputs for regression to verify correct outputs
** Execute the similator from the org document
** Produce final output
** Publish to github
** Submit work
** Have a cup of tea and ruminate upon the exercise..
