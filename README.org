#+options: ^:nil

* Exercise

In this exercise, I am choosing to take a literate programming
approach.  I will be describing the design and writing blocks of
executable code using emacs org-mode babel, which provides the means to both
document and run essential pieces of the similator's code inside this
README.org document itself.

 #+BEGIN_EXAMPLE

         /\
        |==|
        |  |
        |  |
        |  |
       /____\
       |    |
       |Joel|
       |  IX|
       |    |
      /| |  |\
     / | |  | \
    /__|_|__|__\
       /_\/_\
       ######
      ########
       ######
        ####
        ####
         ##
         ##   
         ##
         ##

     #+END_EXAMPLE

** Instructions

Usage:

*** linux

long:

#+BEGIN_EXAMPLE

bin/simulator.sh --field path/of/field/file --script path/of/script/file
      
#+END_EXAMPLE

short:


#+BEGIN_EXAMPLE

bin/simulator.sh -f path/of/field/file --s path/of/script/file
      
#+END_EXAMPLE

example:

#+BEGIN_EXAMPLE

bin/simulator.sh -f starfleet/tests/test_input/cuboid.dat -s starfleet/tests/test_input/student_minesweeping_script.steps
      
#+END_EXAMPLE

*** windows

long:

#+BEGIN_EXAMPLE

bin\similator.bat --field path\of\field\file -script path\of\script\file\
      
#+END_EXAMPLE

short:

#+BEGIN_EXAMPLE

bin/simulator.sh -f path\of\field\file -s path\of\script\file
      
#+END_EXAMPLE

example:

#+BEGIN_EXAMPLE

bin\simulator.bat -f starfleet\tests\test_input\cuboid.dat -s starfleet\tests\test_input\student_minesweeping_script.steps
      
#+END_EXAMPLE

*** results

The results file will be output in the same directory as the script
file.  It will be named the same except that there will be a .out
extension on it.  This file will be overwritten each time a simulation
is run.

*** test inputs

There is a default directory with a set of test files you can use at
this locations

**** test script
#+BEGIN_EXAMPLE

starfleet/tests/test_input/student_minesweeping_script.steps
      
#+END_EXAMPLE

or: 

#+BEGIN_EXAMPLE

starfleet\tests\test_input\student_minesweeping_script.steps
      
#+END_EXAMPLE


**** test field

=starfleet/tests/test_input/cuboid.dat=

or 

=starfleet\tests\test_input\cuboid.dat=

*** unit tests

There is a suite of tests that can be run with py.test from top level project dir.

#+BEGIN_EXAMPLE

$ py.text
      
#+END_EXAMPLE


**** there is a test coverage website built in.  

You can find it under htmlcov directory.

Run the coverage yourself with:

=bin\test_coverage.bat=

todo: make a .sh script for this.

*** logging

Currently the logs are buing output to the directory where the
commands are executing.

There are a bunch of diagnostics that I put out to console for the
time being.  I'm still debugging and working on the core system, so it
may look a bit crazy when you run it from the cli. 

Just pick up the output file to see the clean results matching the
format desired.



** Work in progress..

*** working

**** cuboid

mine layout
coordinate system
rendering

**** vessel

step execution
navigation
targeting 
firiing
decent

**** step
parsing and lexing instructions
hit tracking
**** computer
***** calculations
smallest rectangle
relative ship centering on dimensions
**** grid
shrinking and growing face
rendering
**** simulator
execution of steps
state machine
**** test suite
***** unit test suite can be run with py.test
fluent expectation based tests
***** test coverage reports in html
builds website
**** facilities
command line execution scripts for both linux and windows
argument options parser with defaults
***** logger
****** output to local files, seperating info from errors
****** configured with local yaml file 

*** todo

**** scoring (not implemented)
better validations
hit mine marking

NEED TO PUT IN MODULE DEPS INTO SETUP.PY
as it is, you'll have to figure out based on what breaks


*** known issues

**** there's a bug with shrininking and growing of space around the ship.
should be fixed by tweaking the simulation.recomput_cuboid() method

*** status

I'm close, but would like to continue work on the system to knock out the remaining features.
If you want to go ahead and begin evaluating the system, please go forward.

*** notables

lots of comprehension and lambda kung-fu for general purpose algorithms
liberal use of generator streams and map,reduce,filtration
pythonic functional idioms preferred over imperatives
test-driven design methodology followed
domain responsibilities are cleanly segmented and appropriately placed
**** developed with:
***** emacs
***** ipython
***** py.test, nose, sure (spec-based semantic assertions)
**** todo:
***** diagram system arch
***** diagram domain models
***** diagram program flow

** publication 

*** pdf

todo:..

*** html

This readme is an executable emacs org file.  It can both run the code
and be publised as HTML.  Github automatically understands .org files,
so we'll use this document to start with.

* Describe design

** requirements
**** pip install:
nose
mockito
sure
pytest
pytest-cov

** running
*** input
**** script file
contains the initial cuboid definition
**** field file
contains the student's mine sweeping solution steps
*** simulator program
serves as the executor of the script and field files
**** components
***** domain

represent's the entities within the simulation

****** input

the input is collected from a cuboid file and the student's script
file.  we put this information into data structures that are
appropriate for the job.  for this purpose we'll need a lexer and a parser.

first we'll consume the cuboid file

#+name: get_cuboid
#+header: :exports both
#+begin_src python 

  cuboid = open("./cuboid.dat", "r").read()
 
  return cuboid

#+end_src

#+RESULTS:
: ..Z..
: .....
: Z...Z
: .....
: ..Z..


next we'll get the steps that the student submitted to the simulator.

#+name: get_steps
#+header: :exports both
#+begin_src python 

  steps = open("./student_minesweeping_script.steps", "r").read().split("\n")

  return steps

#+end_src

#+RESULTS:
| north | delta south | west | gamma east | east | gamma west | south | delta |


****** cuboid

this is a data structure that represents our 3d coordinate system.
here we will turn the string into a cubic data structure that will allow us the track the ships position as it steps through moves.

#+name: build_cuboid
#+header: :exports both
#+begin_src python

  cuboid = """ .Z.
               ...
               Z.Z
               ...
               .Z. """

  # stub validation

  # compute height and width
  width = len(list(cuboid.split()[0].strip()))
  height = len(cuboid.split("\n"))

  # build a mapping char to value
  z_map = {c:i+1 for i,c in enumerate([chr(c) for c in 
                                       range(ord('a'), ord('z')+1)] + [chr(c) for c in range(ord('A'), ord('Z')+1)])}

  #compute depth
  import operator
  import re

  # get the order of the values
  ordered_z = sorted(z_map.items(), key=operator.itemgetter(1))

  # show the ordered_z
  for c,l in ordered_z:
     z = z_map[c] - 1
     print(c, z)

  # find the mines and order them from deepest to most shallow
  mine_chars = list(set(re.findall(r'[a-zA-Z]',cuboid)))

  deepest_mine = reduce(lambda highest,current: current if z_map[current] > z_map[highest] else highest, mine_chars)

  depth = z_map[deepest_mine]


  # generate a cubic data structure of correct dimensions
  cube_space = [[['.' for z in range(depth)] 
                 for y in range(height)] 
                for x in range(width)]

  # compute the mine coordinates in cubic space
  for y,line in enumerate(cuboid.strip().split("\n")):
     for x,char in enumerate(list(line.strip())):
        if char in mine_chars:
           z = z_map[char]-1
           cube_space[x][y][z] = char
           print(x,y,z)

  return cube_space     

#+end_src

#+RESULTS: build_cuboid
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) |
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) |
| (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Z) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) | (. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .) |



****** point (x,y,z)

points within the cuboid are represented as tuples

first we need to be able to find the center point of the x,y plane, in
order to place the ship at it's location

#+name: locate_ship
#+header: :var cuboid=build_cuboid :exports both
#+begin_src python

  def find_center(cuboid):
      width = len(cuboid)
      height = len(cuboid[0])
      center_point = ((width / 2) + (width % 2), (height / 2) + (height % 2))
      return center_point

  center_point = find_center(cuboid)

  return center_point

#+end_src

#+RESULTS: locate_ship
| 2 | 3 |

We also need to be able to recomput the size of the x,y plane based
upon the location of the ship and the mines

#+name: recompute_xy_plane
#+header: :var cuboid=build_cuboid ship_location=locate_ship :exports both
#+begin_src python

"todo"

#+end_src

#+RESULTS: recompute_xy_plane
: None

****** movement (z-1,[x,y,None])

movement within the cuboid corresponds to steps and is done with a
z-axis fall and a potential move on either the x or y axes.

****** distance

distance is tracked between points

this is used to find the center of the cuboid and to determine if
photon torpedo firing_patterns actually hit the mines

there is a hit tracking mechanism that computes a hit based on
distance, postion of points, and the firing pattern

****** firing_pattern (alpha,beta,gama,delta)

firing patterns are just tuples of 2d coordinates.  they are assumed
to go all the way to the bottom of the z-axis.

#+begin_src python

  firing_patterns = [alpha = ((-1, -1), (-1, 1), (1, -1), (1, 1))
                     beta = ((-1, 0), (0, -1), (0, 1), (1, 0))
                     gamma = ((-1, 0), (0, 0), (1, 0))
                     delta = ((0, -1), (0, 0), (0, 1))]

#+end_src


****** vessel (ship)

the ship will have characteristics and behaviors.

characteristics:

position (x,y,z)
firing_patterns

behaviors:

fire
move
fall

#+begin_src python

  class Ship:

      firing_patterns = []

      def fire(self, pattern):
        print "pyoo pyoo pyoo"

#+end_src


****** step

done

****** score

todo:...

****** output

done





** composition

**** cuboid

contains 3d a coordinate system of points

point's will be recomputed with each step

**** grid

in charge of face rendering and adjustment's to position

**** vessel

occupies a point (has a slot for a point)

**** step

represent's an action performed by the simulator

**** simulation

the entry point for executing the simulation.

driver for input, execution, and output

**** computer

hold's calculation logic for geometric positioning and navigation

